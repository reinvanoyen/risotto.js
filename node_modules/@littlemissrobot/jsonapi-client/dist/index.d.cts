interface ClientInterface {
    get: (path: string, options: Record<string, unknown>) => Promise<unknown>;
}

type TQueryParamValue = string | number | string[] | number[];
type TQueryParams = Record<string, TQueryParamValue>;

type TResultSetMeta = {
    query: {
        url: string;
        params: TQueryParams;
    };
    performance: {
        query: number;
        mapping: number;
    };
    count?: number;
    pages?: number;
    perPage?: number;
    excludedByGate?: number;
};

type TNullable<T> = T | null;

type NonMethodKeys<T> = {
    [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
type DataProperties<T> = Pick<T, NonMethodKeys<T>>;

declare class ResultSet<T> implements Iterable<T> {
    /**
     * @private
     */
    private readonly items;
    /**
     *
     */
    meta: TNullable<TResultSetMeta>;
    /**
     * @param initialItems
     */
    constructor(initialItems?: T[]);
    /**
     * @param meta
     */
    setMeta(meta: TResultSetMeta): void;
    [Symbol.iterator](): Iterator<T>;
    get length(): number;
    get(index: number): T;
    push(item: T): number;
    pop(): T | undefined;
    map<U>(callback: (value: T, index: number, array: T[]) => U): U[];
    sort(compareFn?: (a: T, b: T) => number): T[];
    forEach<U>(callback: (value: T, index: number, array: T[]) => U): void;
    filter(callback: (value: T, index: number, array: T[]) => boolean): T[];
    find(callback: (value: T, index: number, array: T[]) => boolean): T | undefined;
    reduce<U>(callback: (accumulator: U, currentValue: T, index: number, array: T[]) => U, initialValue: U): U;
    toArray(): T[];
    concat(resultSet: ResultSet<T>): ResultSet<T>;
    serialize(): Array<DataProperties<T>>;
}

type TFilterOperator = '=' | '<>' | '>' | '>=' | '<' | '<=' | 'STARTS_WITH' | 'CONTAINS' | 'ENDS_WITH' | 'IN' | 'NOT IN' | 'BETWEEN' | 'NOT BETWEEN' | 'IS NULL' | 'IS NOT NULL';

type TMapper<T> = (model: ResponseModelInterface) => T;

type TQueryBuilderGroupingFunction<T> = (query: QueryBuilderInterface<T>) => void;

type TDataGateFunction = (model: ResponseModelInterface) => boolean;

type TEvent = object;
type TEventListener = (event: TEvent) => void;

interface EventBusInterface {
    on: (eventKey: string, listener: TEventListener) => void;
    emit: (eventKey: string, event: TEvent) => void;
}

/**
 * This class provides an easy-to-use interface to build queries
 * specifically for JSON:API
 */
declare class QueryBuilder<T extends Model> implements QueryBuilderInterface<T> {
    /**
     * The locale in which we're going to query the entries
     * @private
     */
    private locale?;
    /**
     * The actual HTTP client
     * @private
     */
    private readonly client;
    /**
     * The event bus to use when emitting events
     * @private
     */
    private readonly events;
    /**
     * The mapping function to use when we received the response
     * @private
     */
    private readonly mapper;
    /**
     * @private
     */
    private readonly endpoint;
    /**
     * The registered query params
     * @private
     */
    private readonly queryParams;
    /**
     * @private
     */
    private pageLimit;
    /**
     * @private
     */
    private pageOffset;
    /**
     * @private
     */
    private dataGate;
    /**
     * The cache policy to pass to the Client once the query executes
     * @private
     */
    private cachePolicy;
    /**
     *
     * @private
     */
    private response;
    /**
     * The last used filter group id, increments with each use of a filter-method to generate a unique filter group name
     * @private
     */
    private lastFilterGroupId;
    /**
     *
     * @private
     */
    private currentFilterGroupName;
    /**
     * @param client
     * @param events
     * @param endpoint
     * @param mapper
     */
    constructor(client: ClientInterface, events: EventBusInterface, endpoint: string, mapper: TMapper<Promise<T>>);
    /**
     * Executes a macro registered on MacroRegistry
     * @param name
     * @param args
     */
    macro(name: string, ...args: unknown[]): this;
    /**
     * @param gateFunction
     */
    gate(gateFunction: TDataGateFunction): this;
    /**
     * Disabled caching on the request
     */
    noCache(): this;
    /**
     * Forces caching on the request
     */
    cache(): this;
    /**
     * Sets the locale of the query
     * @param locale
     */
    setLocale(locale: string): this;
    /**
     * Registers one query param
     * @param name
     * @param value
     */
    param(name: string, value: TQueryParamValue): this;
    /**
     * Registers multiple query params
     * @param params
     */
    params(params: TQueryParams): this;
    /**
     * @param path
     * @param operator
     * @param value
     */
    where(path: string, operator: TFilterOperator, value?: TNullable<TQueryParamValue>): this;
    /**
     * @param path
     * @param values
     */
    whereIn(path: string, values: string[] | number[]): this;
    /**
     * @param path
     * @param values
     */
    whereNotIn(path: string, values: string[] | number[]): this;
    /**
     * @param path
     */
    whereIsNull(path: string): this;
    /**
     * @param path
     */
    whereIsNotNull(path: string): this;
    /**
     * Registers includes (as described by JSON:API)
     * @param includes
     */
    include(includes: string[]): this;
    /**
     * @param amount
     */
    limit(amount: number): this;
    /**
     * @param page
     * @param perPage
     */
    paginate(page: number, perPage: number): this;
    /**
     * @param path
     * @param direction
     */
    sort(path: string, direction?: "asc" | "desc"): this;
    /**
     *
     * @param operator
     * @param groupingFunction
     */
    group(operator: "or" | "and", groupingFunction: TQueryBuilderGroupingFunction<T>): this;
    /**
     * @private
     */
    private createFilterGroupName;
    /**
     * @param groupName
     * @private
     */
    private assignFilterGroupToCurrentFilterGroup;
    /**
     * @param path
     * @private
     */
    private buildUrl;
    /**
     * Executes the query (GET)
     */
    private performGetRequest;
    /**
     * Fetches the endpoint and uses the raw response to pass to the mapper
     */
    getRaw(): Promise<T>;
    /**
     * Maps and returns all entries (paginated) in the response
     */
    get(): Promise<ResultSet<T>>;
    /**
     * Maps and returns all entries across all pages
     */
    all(batchSize?: number): Promise<ResultSet<T>>;
    /**
     * Gets and maps the first item from the query
     */
    first(): Promise<T | ResponseModel>;
    /**
     * Gets a single entry by UUID
     * @param uuid
     */
    find(uuid: string | number): Promise<T>;
    /**
     * Turns the QueryBuilder into a string
     */
    toString(): string;
}

declare abstract class Model {
    /**
     * @protected
     */
    protected static primaryKey: string;
    /**
     * @protected
     */
    protected static defaultMacro: string;
    /**
     * @protected
     */
    protected static endpoint: string;
    /**
     * @protected
     */
    protected static include: string[];
    /**
     * @param response
     */
    static createFromResponse(response: ResponseModelInterface): Promise<any>;
    /**
     * Create a QueryBuilder instance specifically for this model
     */
    static query<T extends typeof Model>(this: T): QueryBuilder<InstanceType<T>>;
    /**
     * @param responseModel
     */
    protected map(responseModel: ResponseModelInterface): unknown;
    /**
     * @param responseModel
     * @protected
     */
    static gate(responseModel: ResponseModelInterface): boolean;
    /**
     *
     */
    serialize<T extends Model>(this: T): DataProperties<T>;
}

type TModelClass<T extends Model = Model> = {
    new (...args: any[]): T;
} & typeof Model;

interface ResponseModelInterface {
    getRawResponse: () => unknown;
    get: <T>(path: string | string[], defaultValue: T) => T;
    hasOne: <T extends Model>(path: string | string[], modelClass?: TModelClass<T>) => Promise<TNullable<T>>;
    hasMany: <T extends Model>(path: string | string[], modelClass?: TModelClass<T>) => Promise<TNullable<T[]>>;
}

declare class ResponseModel implements ResponseModelInterface {
    /**
     * The raw, unprocessed response from the JSON:API
     * @private
     */
    private readonly rawResponse;
    /**
     * @param rawResponse
     */
    constructor(rawResponse: unknown);
    /**
     * Get the raw response from the ResponseModel
     */
    getRawResponse(): unknown;
    /**
     * Gets a field from the node
     * @param path
     * @param defaultValue
     */
    get<T>(path: string | string[], defaultValue: T): T;
    /**
     * Gets a relationship from the node and optionally map it
     * @param path
     * @param modelClass
     */
    hasOne<T extends Model>(path: string | string[], modelClass?: TModelClass<T>): Promise<TNullable<T>>;
    /**
     * @param path
     * @param modelClass
     */
    hasMany<T extends Model>(path: string | string[], modelClass?: TModelClass<T>): Promise<TNullable<T[]>>;
}

type TRawResponse = Object;

interface QueryBuilderInterface<T> {
    noCache: () => this;
    cache: () => this;
    setLocale: (locale: string) => this;
    macro: (name: string, ...args: unknown[]) => this;
    param: (name: string, value: TQueryParamValue) => this;
    params: (params: TQueryParams) => this;
    where: (path: string, operator: TFilterOperator, value: TNullable<TQueryParamValue>) => this;
    include: (includes: string[]) => this;
    limit: (amount: number) => this;
    paginate: (page: number, perPage: number) => this;
    sort: (path: string, direction: 'asc' | 'desc') => this;
    group: (operator: 'or' | 'and', groupingCall: TQueryBuilderGroupingFunction<T>) => this;
    get: () => Promise<ResultSet<T | ResponseModel>>;
    getRaw: () => Promise<T | TRawResponse>;
    find: (id: string) => Promise<T | ResponseModel>;
    first(): Promise<T | ResponseModel>;
    toString: () => string;
}

interface AuthInterface {
    getAuthToken: () => Promise<string>;
    getHttpHeaders: () => Promise<Record<string, string>>;
}

type TAutoMapperSelector = (responseModel: ResponseModelInterface, selectValue: string) => boolean;

type TConfigAttributes = {
    baseUrl: string;
    clientId: string;
    clientSecret: string;
};

type TContainerBindingFunction = (...args: any[]) => any;

type TJsonApiResponse = {
    json_api: Object;
    data: Array<Object>;
    meta?: Record<string, any>;
};

type TQueryBuilderMacroFunction = (query: QueryBuilderInterface<unknown>, ...args: unknown[]) => void;

type TResponseWithData = {
    data: Object;
};

declare class JsonApi {
    static init(config: TConfigAttributes): void;
}

declare class Container {
    /**
     * @private
     */
    private static bindings;
    /**
     * @private
     */
    private static singletonBindings;
    /**
     *
     * @private
     */
    private static instances;
    /**
     *
     * @param name
     * @param bindingCall
     */
    static bind(name: string, bindingCall: TContainerBindingFunction): void;
    /**
     *
     * @param name
     * @param bindingCall
     */
    static singleton(name: string, bindingCall: TContainerBindingFunction): void;
    /**
     *
     * @param name
     * @private
     */
    private static getBinding;
    /**
     * Makes and retrieves a new instance
     * @param name
     * @param args
     */
    static make(name: string, ...args: any[]): any;
}

declare class AutoMapper {
    /**
     *
     * @private
     */
    private static models;
    /**
     *
     * @private
     */
    private static selector;
    /**
     *
     * @param selector
     */
    static setSelector(selector: TAutoMapperSelector): void;
    /**
     *
     * @param modelDefinitions
     */
    static register(modelDefinitions: Record<string, typeof Model>): void;
    /**
     *
     * @param responseModel
     * @private
     */
    private static select;
    /**
     * @param responseModel
     */
    static map(responseModel: ResponseModelInterface): Promise<any>;
}

declare class Client implements ClientInterface {
    /**
     * @private
     */
    private readonly auth;
    /**
     * @private
     */
    private readonly baseUrl;
    /**
     * @param auth
     * @param baseUrl
     */
    constructor(auth: AuthInterface, baseUrl: string);
    /**
     * Fetches the API with a GET request
     */
    get(path: string, options?: {}): Promise<unknown>;
    /**
     * Fetches the API with a POST request
     */
    post(path: string, body: any, options?: {}): Promise<unknown>;
}

declare class Config {
    /**
     * @private
     */
    private static attributes;
    /**
     * @param attributes
     */
    static setAll(attributes: TConfigAttributes): void;
    /**
     * @param attribute
     */
    static get(attribute: keyof TConfigAttributes): string;
}

declare class MacroRegistry {
    /**
     * @private
     */
    private static macros;
    /**
     * @param name
     * @param call
     */
    static register(name: string, call: TQueryBuilderMacroFunction): void;
    /**
     * @param name
     * @param query
     * @param args
     */
    static execute(name: string, query: QueryBuilderInterface<unknown>, args?: unknown[]): void;
}

declare class OAuth implements AuthInterface {
    /**
     * @private
     */
    private readonly baseUrl;
    /**
     * @private
     */
    private readonly clientId;
    /**
     * @private
     */
    private readonly clientSecret;
    /**
     * @param baseUrl
     * @param clientId
     * @param clientSecret
     */
    constructor(baseUrl: string, clientId: string, clientSecret: string);
    /**
     * @private
     */
    private accessToken?;
    /**
     * @private
     */
    private accessTokenExpiryDate?;
    /**
     * Gets the HTTP Headers
     */
    getHttpHeaders(): Promise<Record<string, string>>;
    /**
     * Gets the authentication token
     */
    getAuthToken(): Promise<string>;
    /**
     * Generates a new auth token, stores it as properties and returns it
     */
    private generateAuthToken;
}

declare function events(): any;
declare function on(eventKey: string, listener: TEventListener): any;
declare function off(eventId: number): any;

declare function query(endpoint: string, mapper?: TMapper<any>): any;

declare function client(): any;

export { type AuthInterface, AutoMapper, Client, type ClientInterface, Config, Container, type DataProperties, JsonApi, MacroRegistry, Model, OAuth, QueryBuilder, type QueryBuilderInterface, ResponseModel, type ResponseModelInterface, ResultSet, type TAutoMapperSelector, type TConfigAttributes, type TContainerBindingFunction, type TDataGateFunction, type TJsonApiResponse, type TMapper, type TModelClass, type TNullable, type TQueryBuilderGroupingFunction, type TQueryBuilderMacroFunction, type TQueryParams, type TRawResponse, type TResponseWithData, type TResultSetMeta, client, events, off, on, query };
