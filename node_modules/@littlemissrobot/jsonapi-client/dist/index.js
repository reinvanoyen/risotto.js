var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

// src/Container.ts
var Container = class {
  /**
   *
   * @param name
   * @param bindingCall
   */
  static bind(name, bindingCall) {
    this.bindings[name] = bindingCall;
  }
  /**
   *
   * @param name
   * @param bindingCall
   */
  static singleton(name, bindingCall) {
    this.singletonBindings[name] = bindingCall;
  }
  /**
   *
   * @param name
   * @private
   */
  static getBinding(name) {
    if (!this.bindings[name]) {
      throw new Error(`No dependency was found for name "${name}"`);
    }
    return this.bindings[name];
  }
  /**
   * Makes and retrieves a new instance
   * @param name
   * @param args
   */
  static make(name, ...args) {
    if (this.singletonBindings[name]) {
      if (!this.instances[name]) {
        this.instances[name] = this.singletonBindings[name](...args);
      }
      return this.instances[name];
    }
    return this.getBinding(name)(...args);
  }
};
/**
 * @private
 */
Container.bindings = {};
/**
 * @private
 */
Container.singletonBindings = {};
/**
 *
 * @private
 */
Container.instances = {};

// src/Client.ts
var Client = class {
  /**
   * @param auth
   * @param baseUrl
   */
  constructor(auth, baseUrl) {
    this.auth = auth;
    this.baseUrl = baseUrl;
  }
  /**
   * Fetches the API with a GET request
   */
  async get(path, options = {}) {
    const authHeaders = await this.auth.getHttpHeaders();
    const response = await fetch(`${this.baseUrl}/${path}`, __spreadProps(__spreadValues({}, options), {
      method: "GET",
      headers: new Headers(__spreadProps(__spreadValues({}, authHeaders), {
        Accept: "application/vnd.api+json"
      }))
    }));
    try {
      return await response.json();
    } catch (e) {
      throw new Error("Response was not valid JSON.");
    }
  }
  /**
   * Fetches the API with a POST request
   */
  async post(path, body, options = {}) {
    const authHeaders = await this.auth.getHttpHeaders();
    const response = await fetch(`${this.baseUrl}/${path}`, __spreadProps(__spreadValues({}, options), {
      method: "POST",
      headers: new Headers(__spreadProps(__spreadValues({}, authHeaders), {
        Accept: "application/json",
        "Content-Type": "application/json"
      })),
      body: JSON.stringify(body)
    }));
    try {
      return await response.json();
    } catch (e) {
      throw new Error("Response was not valid JSON.");
    }
  }
};

// src/errors/ConfigValuesNotSetError.ts
var ConfigValuesNotSetError = class extends Error {
  constructor() {
    super("Config values are not set");
    this.name = "ConfigValuesNotSetError";
  }
};

// src/errors/FalsyConfigValueError.ts
var FalsyConfigValueError = class extends Error {
  constructor(attributeName) {
    super(`Falsy config value: ${attributeName}`);
    this.name = "FalsyConfigValueError";
  }
};

// src/errors/UnknownConfigValueError.ts
var UnknownConfigValueError = class extends Error {
  constructor(attributeName) {
    super(`Unknown or undefined config value: ${attributeName}`);
    this.name = "UnknownConfigValueError";
  }
};

// src/Config.ts
var Config = class {
  /**
   * @param attributes
   */
  static setAll(attributes) {
    const keys = Object.keys(attributes);
    keys.forEach((key) => {
      if (!attributes[key]) {
        throw new FalsyConfigValueError(key);
      }
    });
    this.attributes = attributes;
  }
  /**
   * @param attribute
   */
  static get(attribute) {
    if (this.attributes === null) {
      throw new ConfigValuesNotSetError();
    }
    if (!this.attributes[attribute]) {
      throw new UnknownConfigValueError(attribute);
    }
    return this.attributes[attribute];
  }
};
/**
 * @private
 */
Config.attributes = null;

// src/errors/UnknownMacroError.ts
var UnknownMacroError = class extends Error {
  constructor(macroName) {
    super(`Unknown macro: ${macroName}`);
    this.name = "UnknownMacroError";
  }
};

// src/MacroRegistry.ts
var MacroRegistry = class {
  /**
   * @param name
   * @param call
   */
  static register(name, call) {
    this.macros[name] = call;
  }
  /**
   * @param name
   * @param query
   * @param args
   */
  static execute(name, query2, args = []) {
    if (!this.macros[name]) {
      throw new UnknownMacroError(name);
    }
    this.macros[name].call(this, query2, ...args);
  }
};
/**
 * @private
 */
MacroRegistry.macros = {};

// src/AutoMapper.ts
var AutoMapper = class {
  /**
   *
   * @param selector
   */
  static setSelector(selector) {
    this.selector = selector;
  }
  /**
   *
   * @param modelDefinitions
   */
  static register(modelDefinitions) {
    this.models = modelDefinitions;
  }
  /**
   *
   * @param responseModel
   * @private
   */
  static select(responseModel) {
    for (const value in this.models) {
      if (this.selector && this.selector(responseModel, value)) {
        return this.models[value];
      }
    }
    return null;
  }
  /**
   * @param responseModel
   */
  static async map(responseModel) {
    const ModelClass = this.select(responseModel);
    if (ModelClass) {
      return await ModelClass.createFromResponse(responseModel);
    }
    return responseModel;
  }
};
/**
 *
 * @private
 */
AutoMapper.models = {};

// src/typeguards/isResponseWithData.ts
function isResponseWithData(value) {
  return typeof value === "object" && value !== null && "data" in value;
}

// src/ResponseModel.ts
var ResponseModel = class _ResponseModel {
  /**
   * @param rawResponse
   */
  constructor(rawResponse) {
    this.rawResponse = rawResponse;
  }
  /**
   * Get the raw response from the ResponseModel
   */
  getRawResponse() {
    return this.rawResponse;
  }
  /**
   * Gets a field from the node
   * @param path
   * @param defaultValue
   */
  get(path, defaultValue) {
    if (!Array.isArray(path)) {
      path = path.replace(/\[(\d+)\]/g, ".$1").split(".");
    }
    let result = this.rawResponse;
    for (const key of path) {
      result = Object.prototype.hasOwnProperty.call(result, key) ? result[key] : void 0;
      if (result === void 0 || result === null) {
        return defaultValue;
      }
    }
    return result;
  }
  /**
   * Gets a relationship from the node and optionally map it
   * @param path
   * @param modelClass
   */
  async hasOne(path, modelClass) {
    let contentData = this.get(path, null);
    if (isResponseWithData(contentData)) {
      contentData = contentData.data;
    }
    if (!contentData) {
      return null;
    }
    const responseModel = new _ResponseModel(contentData);
    if (modelClass) {
      return await modelClass.createFromResponse(responseModel);
    }
    return await AutoMapper.map(responseModel);
  }
  /**
   * @param path
   * @param modelClass
   */
  async hasMany(path, modelClass) {
    let contentData = this.get(path, null);
    if (!contentData) {
      return null;
    }
    if (isResponseWithData(contentData)) {
      contentData = contentData.data;
    }
    if (Array.isArray(contentData)) {
      const result = [];
      for (const item of contentData) {
        const modelInstance = modelClass ? await modelClass.createFromResponse(new _ResponseModel(item)) : await AutoMapper.map(new _ResponseModel(item));
        if (modelInstance) {
          result.push(modelInstance);
        }
      }
      return result;
    }
    return null;
  }
};

// src/Model.ts
var _Model = class _Model {
  /**
   * @param response
   */
  static async createFromResponse(response) {
    if (!this.gate(response)) {
      return null;
    }
    const instance = new this();
    Object.assign(instance, await instance.map(response));
    return instance;
  }
  /**
   * Create a QueryBuilder instance specifically for this model
   */
  static query() {
    if (!this.endpoint) {
      throw new Error(`The model "${this.name}" doesn't have an endpoint, so can't be queried.`);
    }
    const mapper = async (response) => {
      return await this.createFromResponse(response);
    };
    const query2 = Container.make("QueryBuilderInterface", this.endpoint, mapper).gate(this.gate).include(this.include);
    if (this.defaultMacro) {
      query2.macro(this.defaultMacro);
    }
    return query2;
  }
  /**
   * @param responseModel
   */
  map(responseModel) {
    return responseModel;
  }
  /**
   * @param responseModel
   * @protected
   */
  static gate(responseModel) {
    return true;
  }
  /**
   *
   */
  serialize() {
    const data = {};
    for (const key of Object.keys(this)) {
      const value = this[key];
      if (value instanceof _Model) {
        data[key] = value.serialize();
      } else if (Array.isArray(value)) {
        data[key] = value.map(
          (v) => v instanceof _Model ? v.serialize() : v
        );
      } else {
        data[key] = value;
      }
    }
    return data;
  }
};
/**
 * @protected
 */
_Model.primaryKey = "id";
/**
 * @protected
 */
_Model.include = [];
var Model = _Model;

// src/ResultSet.ts
var ResultSet = class _ResultSet {
  /**
   * @param initialItems
   */
  constructor(initialItems = []) {
    /**
     * @private
     */
    this.items = [];
    /**
     *
     */
    this.meta = null;
    this.items = initialItems;
  }
  /**
   * @param meta
   */
  setMeta(meta) {
    this.meta = meta;
  }
  // Make the class iterable by implementing Symbol.iterator
  [Symbol.iterator]() {
    let index = 0;
    const items = this.items;
    return {
      next() {
        if (index < items.length) {
          return { value: items[index++], done: false };
        } else {
          return { value: void 0, done: true };
        }
      }
    };
  }
  get length() {
    return this.items.length;
  }
  get(index) {
    return this.items[index];
  }
  // Array-like methods, delegating to the internal array
  push(item) {
    return this.items.push(item);
  }
  pop() {
    return this.items.pop();
  }
  map(callback) {
    return this.items.map(callback);
  }
  sort(compareFn) {
    this.items.sort(compareFn);
    return this.items;
  }
  forEach(callback) {
    return this.items.forEach(callback);
  }
  filter(callback) {
    return this.items.filter(callback);
  }
  find(callback) {
    return this.items.find(callback);
  }
  reduce(callback, initialValue) {
    return this.items.reduce(callback, initialValue);
  }
  toArray() {
    return this.items;
  }
  concat(resultSet) {
    const originalMeta = this.meta;
    const newMeta = resultSet.meta;
    const newResultSet = new _ResultSet(this.toArray().concat(resultSet.toArray()));
    newResultSet.setMeta(__spreadProps(__spreadValues({}, originalMeta), {
      performance: {
        query: originalMeta.performance.query + newMeta.performance.query,
        mapping: originalMeta.performance.mapping + newMeta.performance.mapping
      },
      excludedByGate: originalMeta.excludedByGate + newMeta.excludedByGate
    }));
    return newResultSet;
  }
  serialize() {
    return this.items.map((item) => {
      if (item instanceof Model) {
        return item.serialize();
      }
      return item;
    });
  }
};

// src/errors/InvalidResponseError.ts
var InvalidResponseError = class extends Error {
  constructor(additionalMessage = "Unknown reason") {
    super(`Invalid response: ${additionalMessage}`);
    this.name = "InvalidResponseError";
  }
};

// src/typeguards/isJsonApiResponse.ts
function isJsonApiResponse(value) {
  return typeof value === "object" && value !== null && "jsonapi" in value && "data" in value && typeof value.data === "object" && value.jsonapi !== null && typeof value.jsonapi === "object" && "version" in value.jsonapi && typeof value.jsonapi.version === "string" && value.jsonapi.version.startsWith("1");
}

// src/typeguards/isRawResponse.ts
function isRawResponse(value) {
  return typeof value === "object" && value !== null;
}

// src/typeguards/isResponseWithErrors.ts
function isResponseWithErrors(value) {
  return typeof value === "object" && value !== null && "errors" in value && Array.isArray(value.errors) && value.errors.length > 0;
}

// src/utils/http.ts
function makeSearchParams(params) {
  const searchParams = new URLSearchParams();
  const paramKeys = Object.keys(params);
  paramKeys.forEach((paramKey) => {
    if (Array.isArray(params[paramKey])) {
      params[paramKey].forEach((value, index) => {
        searchParams.append(`${paramKey}[${index + 1}]`, value);
      });
    } else {
      searchParams.append(paramKey, params[paramKey]);
    }
  });
  return searchParams;
}

// src/QueryBuilder.ts
var QueryBuilder = class {
  /**
   * @param client
   * @param events
   * @param endpoint
   * @param mapper
   */
  constructor(client2, events2, endpoint, mapper) {
    /**
     * @private
     */
    this.pageLimit = null;
    /**
     * @private
     */
    this.pageOffset = null;
    /**
     * @private
     */
    this.dataGate = null;
    /**
     * The cache policy to pass to the Client once the query executes
     * @private
     */
    this.cachePolicy = "force-cache";
    /**
     * The last used filter group id, increments with each use of a filter-method to generate a unique filter group name
     * @private
     */
    this.lastFilterGroupId = 0;
    /**
     *
     * @private
     */
    this.currentFilterGroupName = null;
    this.client = client2;
    this.events = events2;
    this.endpoint = endpoint;
    this.mapper = mapper;
    this.queryParams = {};
  }
  /**
   * Executes a macro registered on MacroRegistry
   * @param name
   * @param args
   */
  macro(name, ...args) {
    MacroRegistry.execute(name, this, args);
    return this;
  }
  /**
   * @param gateFunction
   */
  gate(gateFunction) {
    this.dataGate = gateFunction;
    return this;
  }
  /**
   * Disabled caching on the request
   */
  noCache() {
    this.cachePolicy = "no-store";
    return this;
  }
  /**
   * Forces caching on the request
   */
  cache() {
    this.cachePolicy = "force-cache";
    return this;
  }
  /**
   * Sets the locale of the query
   * @param locale
   */
  setLocale(locale) {
    this.locale = locale;
    return this;
  }
  /**
   * Registers one query param
   * @param name
   * @param value
   */
  param(name, value) {
    this.queryParams[name] = value;
    this.events.emit("paramAdded", { name, value });
    return this;
  }
  /**
   * Registers multiple query params
   * @param params
   */
  params(params) {
    Object.keys(params).forEach((key) => {
      this.param(key, params[key]);
    });
    return this;
  }
  /**
   * @param path
   * @param operator
   * @param value
   */
  where(path, operator, value = null) {
    const groupName = this.createFilterGroupName();
    this.assignFilterGroupToCurrentFilterGroup(groupName);
    this.param(`filter[${groupName}][condition][path]`, path);
    this.param(`filter[${groupName}][condition][operator]`, operator);
    if (value === null) {
      if (operator === "IS NULL" || operator === "IS NOT NULL") {
        return this;
      }
      throw new TypeError(`Value given was null, while the given operator ${operator} expects string or array of strings`);
    }
    if ((operator === "BETWEEN" || operator === "NOT BETWEEN") && (!Array.isArray(value) || value.length !== 2)) {
      throw new TypeError(`Operator ${operator} expects an array with exactly 2 items`);
    }
    if (operator === "IN" || operator === "NOT IN") {
      if (Array.isArray(value)) {
        this.param(`filter[${groupName}][condition][value]`, value);
        return this;
      }
      this.param(`filter[${groupName}][condition][value]`, [value]);
      return this;
    }
    if (Array.isArray(value)) {
      this.param(`filter[${groupName}][condition][value]`, value.join(""));
      return this;
    }
    this.param(`filter[${groupName}][condition][value]`, value);
    return this;
  }
  /**
   * @param path
   * @param values
   */
  whereIn(path, values) {
    this.where(path, "IN", values);
    return this;
  }
  /**
   * @param path
   * @param values
   */
  whereNotIn(path, values) {
    this.where(path, "NOT IN", values);
    return this;
  }
  /**
   * @param path
   */
  whereIsNull(path) {
    this.where(path, "IS NULL");
    return this;
  }
  /**
   * @param path
   */
  whereIsNotNull(path) {
    this.where(path, "IS NOT NULL");
    return this;
  }
  /**
   * Registers includes (as described by JSON:API)
   * @param includes
   */
  include(includes) {
    if (includes.length) {
      this.param("jsonapi_include", 1);
      this.param("include", includes.join(","));
    }
    return this;
  }
  /**
   * @param amount
   */
  limit(amount) {
    this.pageLimit = amount;
    this.param("page[limit]", amount);
    return this;
  }
  /**
   * @param page
   * @param perPage
   */
  paginate(page, perPage) {
    const offset = Math.max(page - 1, 0) * perPage;
    this.pageOffset = offset;
    this.param("page[offset]", offset);
    this.limit(perPage);
    return this;
  }
  /**
   * @param path
   * @param direction
   */
  sort(path, direction = "asc") {
    const groupName = this.createFilterGroupName();
    this.param(`sort[${groupName}][path]`, path);
    this.param(`sort[${groupName}][direction]`, direction);
    return this;
  }
  /**
   *
   * @param operator
   * @param groupingFunction
   */
  group(operator, groupingFunction) {
    const currentFilterGroupName = this.currentFilterGroupName;
    const newGroupName = this.createFilterGroupName();
    this.assignFilterGroupToCurrentFilterGroup(newGroupName);
    this.currentFilterGroupName = newGroupName;
    this.param(`filter[${this.currentFilterGroupName}][group][conjunction]`, operator.toUpperCase());
    groupingFunction(this);
    this.currentFilterGroupName = currentFilterGroupName;
    return this;
  }
  /**
   * @private
   */
  createFilterGroupName() {
    this.lastFilterGroupId = this.lastFilterGroupId + 1;
    return `g${this.lastFilterGroupId}`;
  }
  /**
   * @param groupName
   * @private
   */
  assignFilterGroupToCurrentFilterGroup(groupName) {
    if (this.currentFilterGroupName) {
      this.param(`filter[${groupName}][condition][memberOf]`, this.currentFilterGroupName);
    }
  }
  /**
   * @param path
   * @private
   */
  buildUrl(path) {
    const queryString = makeSearchParams(this.queryParams).toString();
    return `${this.locale ? `${this.locale}/` : ""}${path}/${queryString ? `?${queryString}` : ""}`;
  }
  /**
   * Executes the query (GET)
   */
  async performGetRequest(path) {
    this.events.emit("preFetch", { url: path });
    const response = await this.client.get(path, {
      cache: this.cachePolicy
    });
    this.events.emit("postFetch", { url: path });
    return response;
  }
  /**
   * Fetches the endpoint and uses the raw response to pass to the mapper
   */
  async getRaw() {
    const response = await this.performGetRequest(this.buildUrl(this.endpoint));
    if (!isRawResponse(response)) {
      throw new InvalidResponseError();
    }
    if (!this.mapper) {
      throw new Error("No mapper");
    }
    return await this.mapper(new ResponseModel(response));
  }
  /**
   * Maps and returns all entries (paginated) in the response
   */
  async get() {
    let start = performance.now();
    const url = this.buildUrl(this.endpoint);
    const response = await this.performGetRequest(url);
    if (isResponseWithErrors(response)) {
      const firstError = response.errors[0];
      throw new InvalidResponseError(`${firstError.title} (status: ${firstError.status}): ${firstError.detail}`);
    }
    if (!isJsonApiResponse(response)) {
      throw new InvalidResponseError(
        "Couldn't verify the response as a valid JSON:API response. Potentially this is not a JSON:API resource or the JSON:API has a version mismatch (expected 1.0)"
      );
    }
    this.response = response;
    const queryDuration = performance.now() - start;
    start = performance.now();
    const responseModels = this.response.data.map((entry) => new ResponseModel(entry));
    if (!this.mapper) {
      throw new Error("No mapper");
    }
    const resultSet = new ResultSet();
    let itemCountExcludedByGate = 0;
    try {
      for (var iter = __forAwait(responseModels), more, temp, error; more = !(temp = await iter.next()).done; more = false) {
        const item = temp.value;
        if (this.dataGate && !this.dataGate(item)) {
          itemCountExcludedByGate++;
          continue;
        }
        const mapped = await this.mapper(item);
        resultSet.push(mapped);
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && await temp.call(iter);
      } finally {
        if (error)
          throw error[0];
      }
    }
    const mappingDuration = performance.now() - start;
    let meta = {
      query: {
        url,
        params: this.queryParams
      },
      performance: {
        query: queryDuration,
        mapping: mappingDuration
      },
      excludedByGate: itemCountExcludedByGate
    };
    if (this.response.meta) {
      meta = __spreadValues({
        count: this.response.meta.count || 0,
        pages: this.pageLimit ? Math.ceil(this.response.meta.count / this.pageLimit) : 1,
        perPage: this.pageLimit ? this.pageLimit : this.response.meta.count
      }, meta);
    }
    resultSet.setMeta(meta);
    return resultSet;
  }
  /**
   * Maps and returns all entries across all pages
   */
  async all(batchSize = 50) {
    this.paginate(1, batchSize);
    const firstResult = await this.get();
    const { pages, perPage } = firstResult.meta;
    if (pages === 1) {
      return firstResult;
    }
    let currentPage = 2;
    let resultSet = firstResult;
    while (currentPage <= pages) {
      const pagedResult = await this.paginate(currentPage, perPage).get();
      resultSet = resultSet.concat(pagedResult);
      currentPage++;
    }
    resultSet.setMeta(__spreadProps(__spreadValues({}, resultSet.meta), {
      pages: 1,
      perPage: resultSet.meta.count
    }));
    return resultSet;
  }
  /**
   * Gets and maps the first item from the query
   */
  async first() {
    return (await this.get()).get(0);
  }
  /**
   * Gets a single entry by UUID
   * @param uuid
   */
  async find(uuid) {
    if (!this.mapper) {
      throw new Error("No mapper");
    }
    const response = await this.performGetRequest(this.buildUrl(`${this.endpoint}/${uuid}`));
    if (isResponseWithErrors(response)) {
      const firstError = response.errors[0];
      throw new InvalidResponseError(`${firstError.title} (status: ${firstError.status}): ${firstError.detail}`);
    }
    if (!isJsonApiResponse(response)) {
      throw new InvalidResponseError(
        "Couldn't verify the response as a valid JSON:API response. Potentially this is not a JSON:API resource or the JSON:API has a version mismatch (expected 1.0)"
      );
    }
    this.response = response;
    return this.mapper(new ResponseModel(this.response.data));
  }
  /**
   * Turns the QueryBuilder into a string
   */
  toString() {
    return this.buildUrl(this.endpoint);
  }
};

// src/errors/AuthTokenError.ts
var AuthTokenError = class extends Error {
  constructor(message, url = "") {
    super(`Couldn't generate auth token: ${message}. Using URL ${url}. Are you sure your credentials are correct and the API responds with a JSON:API response?`);
    this.name = "AuthTokenError";
  }
};

// src/auth/OAuth.ts
var OAuth = class {
  /**
   * @param baseUrl
   * @param clientId
   * @param clientSecret
   */
  constructor(baseUrl, clientId, clientSecret) {
    this.baseUrl = baseUrl;
    this.clientId = clientId;
    this.clientSecret = clientSecret;
  }
  /**
   * Gets the HTTP Headers
   */
  async getHttpHeaders() {
    const token = await this.getAuthToken();
    return {
      Authorization: `Bearer ${token}`
    };
  }
  /**
   * Gets the authentication token
   */
  async getAuthToken() {
    if (!this.accessToken || !this.accessTokenExpiryDate || (/* @__PURE__ */ new Date()).getTime() >= this.accessTokenExpiryDate) {
      return await this.generateAuthToken();
    }
    return this.accessToken;
  }
  /**
   * Generates a new auth token, stores it as properties and returns it
   */
  async generateAuthToken() {
    const url = `${this.baseUrl}/oauth/token`;
    const requestBody = new FormData();
    requestBody.append("grant_type", "client_credentials");
    requestBody.append("client_id", this.clientId);
    requestBody.append("client_secret", this.clientSecret);
    let json;
    try {
      const response = await fetch(url, {
        method: "POST",
        body: requestBody,
        headers: {
          Accept: "application/json"
        }
      });
      json = await response.json();
    } catch (e) {
      if (e instanceof Error) {
        throw new AuthTokenError(e.message, url);
      }
      throw new AuthTokenError(`Couldn't generate auth token: Unknown error.`, url);
    }
    if (!json.access_token) {
      throw new AuthTokenError(`${json.error}: ${json.error_description}`, url);
    }
    this.accessToken = json.access_token;
    this.accessTokenExpiryDate = (/* @__PURE__ */ new Date()).getTime() + json.expires_in;
    return this.accessToken;
  }
};

// src/EventBus.ts
var EventBus = class {
  constructor() {
    /**
     * The current id
     * @private
     */
    this.currentId = 0;
    /**
     *
     * @private
     */
    this.eventIdMap = {};
    /**
     * The registered event listeners
     */
    this.listeners = {};
  }
  /**
   * Adds an event listener
   * @param eventKey
   * @param listener
   */
  on(eventKey, listener) {
    const id = ++this.currentId;
    if (!this.listeners[eventKey]) {
      this.listeners[eventKey] = [];
    }
    this.eventIdMap[id] = eventKey;
    this.listeners[eventKey].push({ id, listener });
    return () => this.off(id);
  }
  /**
   * Removes an event listener
   * @param eventId
   */
  off(eventId) {
    const eventKey = this.eventIdMap[eventId];
    if (!eventKey) {
      return;
    }
    const listeners = this.listeners[eventKey];
    if (!listeners || !listeners.length) {
      return;
    }
    this.listeners[eventKey] = listeners.filter((listenerEntry) => {
      return listenerEntry.id !== eventId;
    });
    delete this.eventIdMap[eventId];
  }
  /**
   * Emits an event with the given event data
   * @param eventKey
   * @param event
   */
  emit(eventKey, event = {}) {
    if (!this.listeners[eventKey]) {
      return;
    }
    this.listeners[eventKey].forEach((listenerEntry) => {
      listenerEntry.listener(event);
    });
  }
};

// src/JsonApi.ts
var JsonApi = class {
  static init(config) {
    Config.setAll(config);
    Container.singleton("EventBusInterface", () => {
      return new EventBus();
    });
    Container.bind("QueryBuilderInterface", (endpoint, mapper) => {
      return new QueryBuilder(
        Container.make("ClientInterface"),
        Container.make("EventBusInterface"),
        endpoint,
        mapper
      );
    });
    Container.singleton("AuthInterface", () => {
      return new OAuth(
        Config.get("baseUrl"),
        Config.get("clientId"),
        Config.get("clientSecret")
      );
    });
    Container.singleton("ClientInterface", () => {
      return new Client(Container.make("AuthInterface"), Config.get("baseUrl"));
    });
  }
};

// src/facades/events.ts
function events() {
  return Container.make("EventBusInterface");
}
function on(eventKey, listener) {
  return events().on(eventKey, listener);
}
function off(eventId) {
  return events().off(eventId);
}

// src/facades/query.ts
var defaultMapper = (response) => {
  return response;
};
function query(endpoint, mapper = defaultMapper) {
  return Container.make("QueryBuilderInterface", endpoint, mapper);
}

// src/facades/client.ts
function client() {
  return Container.make("ClientInterface");
}
export {
  AutoMapper,
  Client,
  Config,
  Container,
  JsonApi,
  MacroRegistry,
  Model,
  OAuth,
  QueryBuilder,
  ResponseModel,
  ResultSet,
  client,
  events,
  off,
  on,
  query
};
//# sourceMappingURL=index.js.map